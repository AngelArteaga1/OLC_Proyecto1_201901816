
//----------------------------------------------------
// The following code was generated by CUP v0.11b 20160615 (GIT 4ac7450)
//----------------------------------------------------

package Analizadores;

import java_cup.runtime.*;
import Application.*;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;
import java_cup.runtime.XMLElement;

/** CUP v0.11b 20160615 (GIT 4ac7450) generated parser.
  */
@SuppressWarnings({"rawtypes"})
public class parser extends java_cup.runtime.lr_parser {

 public final Class getSymbolContainer() {
    return sym.class;
}

  /** Default constructor. */
  @Deprecated
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  @Deprecated
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\064\000\002\002\004\000\002\002\013\000\002\003" +
    "\011\000\002\003\012\000\002\004\005\000\002\004\003" +
    "\000\002\010\005\000\002\010\003\000\002\007\003\000" +
    "\002\007\003\000\002\007\003\000\002\007\003\000\002" +
    "\007\003\000\002\007\003\000\002\007\003\000\002\007" +
    "\003\000\002\007\003\000\002\007\003\000\002\007\003" +
    "\000\002\007\003\000\002\007\003\000\002\007\003\000" +
    "\002\007\003\000\002\007\003\000\002\007\003\000\002" +
    "\007\003\000\002\007\003\000\002\007\003\000\002\007" +
    "\003\000\002\007\003\000\002\007\003\000\002\007\003" +
    "\000\002\007\003\000\002\007\003\000\002\007\003\000" +
    "\002\007\003\000\002\007\003\000\002\007\003\000\002" +
    "\007\003\000\002\005\007\000\002\005\010\000\002\011" +
    "\005\000\002\011\005\000\002\011\004\000\002\011\004" +
    "\000\002\011\004\000\002\011\003\000\002\012\005\000" +
    "\002\012\003\000\002\012\003\000\002\006\006\000\002" +
    "\006\007" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\143\000\004\004\004\001\002\000\004\017\007\001" +
    "\002\000\004\002\006\001\002\000\004\002\001\001\002" +
    "\000\004\020\140\001\002\000\006\017\011\024\012\001" +
    "\002\000\004\020\065\001\002\000\004\025\061\001\002" +
    "\000\006\013\015\024\014\001\002\000\004\025\033\001" +
    "\002\000\004\013\016\001\002\000\004\013\017\001\002" +
    "\000\004\013\020\001\002\000\004\024\022\001\002\000" +
    "\006\005\027\024\026\001\002\000\004\020\023\001\002" +
    "\000\004\021\024\001\002\000\004\014\025\001\002\000" +
    "\006\005\uffcf\024\uffcf\001\002\000\004\020\030\001\002" +
    "\000\004\002\000\001\002\000\004\021\031\001\002\000" +
    "\004\014\032\001\002\000\006\005\uffce\024\uffce\001\002" +
    "\000\004\026\034\001\002\000\022\004\035\007\041\010" +
    "\045\011\037\012\043\015\044\021\040\022\036\001\002" +
    "\000\004\024\057\001\002\000\024\004\uffd1\007\uffd1\010" +
    "\uffd1\011\uffd1\012\uffd1\014\uffd1\015\uffd1\021\uffd1\022\uffd1" +
    "\001\002\000\022\004\035\007\041\010\045\011\037\012" +
    "\043\015\044\021\040\022\036\001\002\000\024\004\uffd0" +
    "\007\uffd0\010\uffd0\011\uffd0\012\uffd0\014\uffd0\015\uffd0\021" +
    "\uffd0\022\uffd0\001\002\000\022\004\035\007\041\010\045" +
    "\011\037\012\043\015\044\021\040\022\036\001\002\000" +
    "\004\014\053\001\002\000\022\004\035\007\041\010\045" +
    "\011\037\012\043\015\044\021\040\022\036\001\002\000" +
    "\022\004\035\007\041\010\045\011\037\012\043\015\044" +
    "\021\040\022\036\001\002\000\022\004\035\007\041\010" +
    "\045\011\037\012\043\015\044\021\040\022\036\001\002" +
    "\000\024\004\uffd3\007\uffd3\010\uffd3\011\uffd3\012\uffd3\014" +
    "\uffd3\015\uffd3\021\uffd3\022\uffd3\001\002\000\022\004\035" +
    "\007\041\010\045\011\037\012\043\015\044\021\040\022" +
    "\036\001\002\000\024\004\uffd8\007\uffd8\010\uffd8\011\uffd8" +
    "\012\uffd8\014\uffd8\015\uffd8\021\uffd8\022\uffd8\001\002\000" +
    "\024\004\uffd4\007\uffd4\010\uffd4\011\uffd4\012\uffd4\014\uffd4" +
    "\015\uffd4\021\uffd4\022\uffd4\001\002\000\024\004\uffd6\007" +
    "\uffd6\010\uffd6\011\uffd6\012\uffd6\014\uffd6\015\uffd6\021\uffd6" +
    "\022\uffd6\001\002\000\006\013\uffd9\024\uffd9\001\002\000" +
    "\022\004\035\007\041\010\045\011\037\012\043\015\044" +
    "\021\040\022\036\001\002\000\024\004\uffd7\007\uffd7\010" +
    "\uffd7\011\uffd7\012\uffd7\014\uffd7\015\uffd7\021\uffd7\022\uffd7" +
    "\001\002\000\024\004\uffd5\007\uffd5\010\uffd5\011\uffd5\012" +
    "\uffd5\014\uffd5\015\uffd5\021\uffd5\022\uffd5\001\002\000\004" +
    "\005\060\001\002\000\024\004\uffd2\007\uffd2\010\uffd2\011" +
    "\uffd2\012\uffd2\014\uffd2\015\uffd2\021\uffd2\022\uffd2\001\002" +
    "\000\004\026\062\001\002\000\022\004\035\007\041\010" +
    "\045\011\037\012\043\015\044\021\040\022\036\001\002" +
    "\000\004\014\064\001\002\000\006\013\uffda\024\uffda\001" +
    "\002\000\004\024\066\001\002\000\004\025\067\001\002" +
    "\000\004\026\070\001\002\000\100\004\114\005\107\006" +
    "\127\007\121\010\110\011\073\012\071\013\131\014\117" +
    "\015\122\020\116\022\103\023\125\024\132\025\111\026" +
    "\130\027\100\030\075\031\076\032\074\033\124\034\123" +
    "\035\120\036\113\037\106\040\101\041\112\042\105\043" +
    "\104\044\102\045\077\001\002\000\010\006\ufff1\014\ufff1" +
    "\016\ufff1\001\002\000\004\014\137\001\002\000\010\006" +
    "\ufff0\014\ufff0\016\ufff0\001\002\000\010\006\ufff4\014\ufff4" +
    "\016\ufff4\001\002\000\010\006\ufff6\014\ufff6\016\ufff6\001" +
    "\002\000\010\006\ufff7\014\ufff7\016\ufff7\001\002\000\010" +
    "\006\uffdf\014\uffdf\016\uffdf\001\002\000\010\006\ufff8\014" +
    "\ufff8\016\ufff8\001\002\000\010\006\uffe4\014\uffe4\016\uffe4" +
    "\001\002\000\010\006\uffe0\014\uffe0\016\uffe0\001\002\000" +
    "\010\006\uffdb\014\uffdb\016\uffdb\001\002\000\010\006\uffe1" +
    "\014\uffe1\016\uffe1\001\002\000\010\006\uffe2\014\uffe2\016" +
    "\uffe2\001\002\000\010\006\uffe7\014\uffe7\016\uffe7\001\002" +
    "\000\010\006\uffdc\014\uffdc\016\uffdc\001\002\000\010\006" +
    "\uffed\014\uffed\016\uffed\001\002\000\010\006\uffee\014\uffee" +
    "\016\uffee\001\002\000\010\006\uffe3\014\uffe3\016\uffe3\001" +
    "\002\000\010\006\uffe8\014\uffe8\016\uffe8\001\002\000\010" +
    "\006\uffde\014\uffde\016\uffde\001\002\000\006\006\135\014" +
    "\ufffc\001\002\000\010\006\uffea\014\uffea\016\uffea\001\002" +
    "\000\010\006\uffe9\014\uffe9\016\uffe9\001\002\000\010\006" +
    "\uffec\014\uffec\016\uffec\001\002\000\010\006\uffdd\014\uffdd" +
    "\016\uffdd\001\002\000\010\006\uffe5\014\uffe5\016\uffe5\001" +
    "\002\000\010\006\ufff2\014\ufff2\016\ufff2\001\002\000\010" +
    "\006\ufff3\014\ufff3\016\ufff3\001\002\000\010\006\uffeb\014" +
    "\uffeb\016\uffeb\001\002\000\010\006\ufffa\014\ufffa\016\133" +
    "\001\002\000\010\006\uffef\014\uffef\016\uffef\001\002\000" +
    "\010\006\uffe6\014\uffe6\016\uffe6\001\002\000\010\006\ufff5" +
    "\014\ufff5\016\ufff5\001\002\000\010\006\ufff9\014\ufff9\016" +
    "\ufff9\001\002\000\100\004\114\005\107\006\127\007\121" +
    "\010\110\011\073\012\071\013\131\014\117\015\122\020" +
    "\116\022\103\023\125\024\132\025\111\026\130\027\100" +
    "\030\075\031\076\032\074\033\124\034\123\035\120\036" +
    "\113\037\106\040\101\041\112\042\105\043\104\044\102" +
    "\045\077\001\002\000\004\014\ufffd\001\002\000\100\004" +
    "\114\005\107\006\127\007\121\010\110\011\073\012\071" +
    "\013\131\014\117\015\122\020\116\022\103\023\125\024" +
    "\132\025\111\026\130\027\100\030\075\031\076\032\074" +
    "\033\124\034\123\035\120\036\113\037\106\040\101\041" +
    "\112\042\105\043\104\044\102\045\077\001\002\000\006" +
    "\006\ufffb\014\ufffb\001\002\000\006\017\ufffe\024\ufffe\001" +
    "\002\000\004\024\141\001\002\000\004\025\142\001\002" +
    "\000\004\026\143\001\002\000\100\004\114\005\107\006" +
    "\127\007\121\010\110\011\073\012\071\013\131\014\117" +
    "\015\122\020\116\022\103\023\125\024\132\025\111\026" +
    "\130\027\100\030\075\031\076\032\074\033\124\034\123" +
    "\035\120\036\113\037\106\040\101\041\112\042\105\043" +
    "\104\044\102\045\077\001\002\000\004\014\145\001\002" +
    "\000\006\017\uffff\024\uffff\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\143\000\004\002\004\001\001\000\004\003\007\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\005\012\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\006\020\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\011\041\012\045\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\011\055" +
    "\012\045\001\001\000\002\001\001\000\006\011\053\012" +
    "\045\001\001\000\002\001\001\000\006\011\051\012\045" +
    "\001\001\000\006\011\050\012\045\001\001\000\006\011" +
    "\046\012\045\001\001\000\002\001\001\000\006\011\047" +
    "\012\045\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\006\011\054\012\045" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\011\062" +
    "\012\045\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\004\071\007\125\010\114\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\007\133\001\001\000\002\001\001\000\004" +
    "\007\135\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\010" +
    "\004\143\007\125\010\114\001\001\000\002\001\001\000" +
    "\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  
    public static int contId=1;
    public static Nodo Raiz;
    public static int num = 1;
    public static int contCon = 0;
    public static int contEs = 0;
    public static List<TablaSiguientes> ListaSiguientes;
    public static List<Estado> estados;
    public static List<Integer> ListaAuxiliar;
    public static int[][] Transiciones;
    public static List<String> conjuntos;
    public static List<String> Caracteres = new ArrayList<String>();

    public static void GraficarErrores(){
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("Errores.html");
            pw = new PrintWriter(fichero);
            //EMPEZAMOS EL DOCUMENTO HTML       
            pw.println("<!doctype html>");
            pw.println("<head>");
            pw.println("<meta charset=\"utf-8\">");
            pw.println("<meta name=\"author\" content=\"Angel Arteaga\">");
            pw.println("<meta name=\"descripción\" content=\"Errores de entrada\">");
            pw.println("<title>Errores De Entrada</title>");
            pw.println("</head>");
            pw.println("<style>");
            pw.println("table.GeneratedTable {width: 100%;background-color: #ffffff;border-collapse: collapse;border-width: 2px;border-color: #a2f575;border-style: solid;color: #000000;}");
            pw.println("table.GeneratedTable td, table.GeneratedTable th {border-width: 2px;border-color: #a2f575;border-style: solid;padding: 3px;}");
            pw.println("table.GeneratedTable thead {background-color: #bcf98b;}");
            pw.println("</style>");
            pw.println("<body>");
            pw.println("<table class=\"GeneratedTable\">");
            pw.println("<thead><tr><th>Número #</th><th>Tipo de Error</th><th>Descripción</th><th>Línea</th><th>Columna</th></tr></thead>");
            pw.println("<tbody>");
            //AHORA LA PARTE DINAMICA
            for (int i = 0; i < Application.App.ListaErrores.size(); i++){
                pw.println("<tr>");
                pw.println("<td>" + i +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Tipo +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Descripcion +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Linea +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Columna +"</td>");
                pw.println("</tr>");
            }

            pw.println("</tbody>");
            pw.println("</table>");
            pw.println("</body>");
            pw.println("</html>");

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
    }

    public static void graficarAFND(String nombre){

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("afd/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");

            pw.println("rankdir=LR");

            pw.println("node[shape=circle]");

            //Generamos los estados 
            for (int i = 0; i < estados.size() -1; i++){
                if (estados.get(i).combinacion.contains(ListaSiguientes.size())){
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\", shape=doublecircle ];");
                } else {
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\"];");
                } 
            }
            //realizamos las transiciones
            for (int i = 0; i < estados.size() - 1; i++){
                for (int j = 0; j < conjuntos.size() - 1; j++){
                    if (Transiciones[i][j] != -1){
                        String conjunto = conjuntos.get(j);
                        if (conjunto.equals("\\n") || conjunto.equals("\\'")||conjunto.equals("\\\"")){
                            conjunto = conjunto.replace("\\", "\\\\");
                        }
                        pw.println("nodo" + i + "->nodo" + Transiciones[i][j] + " [label = \"" + conjunto + "\"]");
                    }

                }
            }

            pw.println("}");

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "afd/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/AFD_201901816/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void graficarAFD(String nombre){

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("afnd/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");

            pw.println("rankdir=LR");

            pw.println("node[shape=circle]");

            //Generamos los estados 
            for (int i = 0; i < estados.size() -1; i++){
                if (estados.get(i).combinacion.contains(ListaSiguientes.size())){
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\", shape=doublecircle ];");
                } else {
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\"];");
                } 
            }
            //realizamos las transiciones
            int x = 1;
            for (int i = 0; i < estados.size() - 1; i++){
                for (int j = 0; j < conjuntos.size() - 1; j++){
                    if (Transiciones[i][j] != -1){
                        String conjunto = conjuntos.get(j);
                        if (conjunto.equals("\\n") || conjunto.equals("\\'")||conjunto.equals("\\\"")){
                            conjunto = conjunto.replace("\\", "\\\\");
                        }
                        pw.println("nodo" + i + "->SS" + x + " [label = \"" + "ε" + "\"]");
                        pw.println("SS" + x + "->nodo" + Transiciones[i][j] + " [label = \"" + conjunto + "\"]");
                    }
                    x++;
                }
            }

            pw.println("}");

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "afnd/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/AFND_201901816/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static boolean Equals(List<Integer> lista1, List<Integer> lista2){
        if (lista1.size() != lista2.size()){
            return false;
        } else {
            for (int i = 0; i < lista1.size(); i++){
                if (lista1.get(i) != lista2.get(i)){
                    return false;
                }
            }
        }
        return true;
    }

    public static void CrearEstados(Estado S){
        boolean encontrado = false;
        for (int i = 0; i < S.combinacion.size(); i++){
            int aux = S.combinacion.get(i);
            //VALIDAR SI LA CONBINACION ES LA MISMA
            for ( int j = 0; j < estados.size(); j++){
                if (Equals(estados.get(j).combinacion, ListaSiguientes.get(aux-1).siguientes) == true){
                    encontrado = true;
                }
            }
            if (encontrado == false){
                Estado nuevo = new Estado(contEs, ListaSiguientes.get(aux-1).siguientes);
                estados.add(nuevo);
                contEs++;
                CrearEstados(nuevo);
            }
            encontrado = false;
        }
    }

    public static void graficarTransiciones(int[] anteriores, String nombre){
        System.out.println("ESTOS SON LOS ESTADOS QUE LOGRÉ CREAR:");
        //PASAMOS EL ARRAY A UNA LISTA
        contEs = 0;
        List<Integer> anterioresList = new ArrayList<Integer>();
        ListaAuxiliar = new ArrayList<Integer>();
        for (int i = 0; i < anteriores.length; i++){
            anterioresList.add(anteriores[i]);
        }
        estados = new ArrayList<Estado>();
        Estado inicial = new Estado(contEs, anterioresList);
        estados.add(inicial);
        contEs++;
        //CREAMOS LOS LOS POSIBLES ESTADOS
        CrearEstados(inicial);
        for (int i = 0; i < estados.size(); i++){
            System.out.println(estados.get(i).S + ", " + estados.get(i).combinacion);
        }

        //CREAMOS LA LISTA DE CONJUNTOS
        conjuntos = new ArrayList<String>();
        for (int i = 0; i < ListaSiguientes.size(); i++){
            if (conjuntos.contains(ListaSiguientes.get(i).valor) == false){
                conjuntos.add(ListaSiguientes.get(i).valor);
            }
        }
        System.out.println(conjuntos);

        //CREAMOS LA MATRIZ DE TRANSICIONES
        Transiciones = new int[estados.size()][conjuntos.size()];
        for (int i = 0; i < estados.size(); i++){
            for  ( int j = 0; j < conjuntos.size(); j++){
                Transiciones[i][j] = -1;
            }
        }

        //INGRESAMOS LOS DATOS A LA MATRIZ
        try{
            //recorremos la lista de estados encontrados
            for (int i = 0; i < estados.size(); i++){
                //recorremos las combinaciones del estado actual
                for (int j = 0; j < estados.get(i).combinacion.size(); j++){
                    //obtenemos el indice de esa combinacion
                    int indice = estados.get(i).combinacion.get(j);
                    //obtenemos el string del conjunto de ese indice
                    String conjunto = GetCadenaConjunto(indice);
                    //recorreremos la lista de estados nuevamente
                    for (int k = 0; k < estados.size(); k++){
                        //sera igual al estado que tenga la misma combinacion para obtener el estado
                        if (Equals(estados.get(k).combinacion, ListaSiguientes.get(indice - 1).siguientes)){
                            Transiciones[i][GetConjunto(conjunto)] = estados.get(k).S;
                        }
                    }
                }
            }

        }catch(Exception e){
            System.err.println(e);
        }

        //IMPRIMIENDO LA MATRIZ
        for (int i = 0; i < estados.size(); i++){
            System.out.println("");
            for  ( int j = 0; j < conjuntos.size(); j++){
                System.out.print(Transiciones[i][j] + ", ");
            }
        }

        //EMPEZAMOS A GRAFICAR
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("Transiciones/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("tbl [");
            pw.println("shape=plaintext");
            pw.println("label=<");
            pw.println("<TABLE border=\"10\" cellspacing=\"10\" cellpadding=\"10\" style=\"rounded\" bgcolor=\"/rdylgn11/1:/rdylgn11/11\" gradientangle=\"315\">");
            //PARA CREAR LA PRIMERA FILA
            pw.println("<TR>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/6:/rdylgn11/9\">Estados</TD>");
            for (int i = 0; i < conjuntos.size() - 1; i++){
                pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/2:/rdylgn11/3\">" + conjuntos.get(i) + "</TD>");
            }
            pw.println("</TR>");
            //PARA CREAR TODAS LAS SITUACIONES
            for (int i = 0; i < estados.size() - 1; i++){
                pw.println("<TR>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/4:/rdylgn11/5\" gradientangle=\"270\">S" + estados.get(i).S + "</TD>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/3:/rdylgn11/9\" gradientangle=\"270\">" + estados.get(i).combinacion + "</TD>");
                for (int j = 0; j < conjuntos.size() - 1; j++){
                    if (Transiciones[i][j] == -1){
                        pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">---</TD>");
                    } else {
                        pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">S" + Transiciones[i][j] + "</TD>");
                    }
                }
                pw.println("</TR>");
            }

            pw.println("</TABLE>");
            pw.println(">];");
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "transiciones/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/Transiciones_201901816/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }


    }

    public static String GetCadenaConjunto(int indice){
        //System.out.println("**********************************************************************");
        //System.out.println("INDICE: " + indice + " VALOR: " + ListaSiguientes.get(indice - 1).valor);
        return ListaSiguientes.get(indice - 1).valor;
    }

    public static int GetConjunto (String conjunto){
        //System.out.println("*********************************************************************");
        int indice = -1;
        for (int i = 0; i < conjuntos.size(); i++){
            //System.out.println(conjuntos.get(i) + "<->" + conjunto);
            if ((conjuntos.get(i)).contains(conjunto) || conjunto.contains(conjuntos.get(i))){
                //System.out.println("LO ENCONTRE PAPA");
                return i;
            }
        }
        System.out.println("CONJUNTO: " + conjunto + " INDICE: " + indice);
        return indice;
    }

    public static void graficarSiguientes(String nombre){
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("siguientes/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("tbl [");
            pw.println("shape=plaintext");
            pw.println("label=<");
            pw.println("<TABLE border=\"10\" cellspacing=\"10\" cellpadding=\"10\" style=\"rounded\" bgcolor=\"/rdylgn11/1:/rdylgn11/11\" gradientangle=\"315\">");
            pw.println("<TR>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/6:/rdylgn11/9\">Simbolos</TD>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/9:/rdylgn11/11\">Siguientes</TD>");
            pw.println("</TR>");

            for (int i = 0; i < ListaSiguientes.size(); i++){
                pw.println("<TR>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/4:/rdylgn11/5\" gradientangle=\"270\">" + ListaSiguientes.get(i).id + "</TD>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/3:/rdylgn11/9\" gradientangle=\"270\">" + ListaSiguientes.get(i).valor + "</TD>");
                pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">" + ListaSiguientes.get(i).siguientes + "</TD>");
                pw.println("</TR>");
            }

            pw.println("</TABLE>");
            pw.println(">];");
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "siguientes/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/Siguientes_201901816/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void graficarArbol(Nodo act, String nombre){

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("arboles/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("rankdir=UD");
            pw.println("node[shape=record]");
            pw.println("concentrate=true");
            pw.println(act.getCodigoInterno());
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "arboles/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/Arboles_201901816/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    //-----------------------------------------para errores sintacticos-------------------------------------------------------------------------------------------
    public void syntax_error(Symbol s)
    {
        App.TxtSalida.append("Error en la Línea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador "+s.value + " no reconocido.\n" );
        Errores err = new Errores("Sintáctico", "El identificador \"" + s.value + "\" no se esperaba.", s.right+1, s.left+1);
        Application.App.ListaErrores.add(err);
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        App.TxtSalida.append("Error en la Línea " + (s.right+1)+ " Columna "+(s.left+1)+". Identificador " +s.value + " no reconocido.\n");
        Errores err = new Errores("Sintáctico", "El identificador \"" + s.value + "\" no se esperaba.", s.right+1, s.left+1);
        Application.App.ListaErrores.add(err);
        GraficarErrores();
    }
    //-------------------------------------------------------------------------------------------------------------------------------------------------------------


/** Cup generated class to encapsulate user supplied action code.*/
@SuppressWarnings({"rawtypes", "unchecked", "unused"})
class CUP$parser$actions {



  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method 0 with the actual generated action code for actions 0 to 300. */
  public final java_cup.runtime.Symbol CUP$parser$do_action_part00000000(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= INICIO EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String start_val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // INICIO ::= TKParA CUERPO EXPRESION TKPorcentaje TKPorcentaje TKPorcentaje TKPorcentaje DEFINICION TKParC 
            {
              String RESULT =null;
		
    App.TxtSalida.append("El archivo se ha leido correctamente.\n");

              CUP$parser$result = parser.getSymbolFactory().newSymbol("INICIO",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // CUERPO ::= TKConj TKDosPuntos identificador TKGuion TKMayor CONJUNTO TKPuntoComa 
            {
              String RESULT =null;
		int conjuntoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int conjuntoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String conjunto = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
    try{
            Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(parser.Caracteres),conjunto));
            parser.Caracteres.clear();
            parser.contCon++;
        }catch(Exception e){
            System.err.println("Error de Conjuntos: " + e);
        }

              CUP$parser$result = parser.getSymbolFactory().newSymbol("CUERPO",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // CUERPO ::= CUERPO TKConj TKDosPuntos identificador TKGuion TKMayor CONJUNTO TKPuntoComa 
            {
              String RESULT =null;
		int conjuntoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int conjuntoright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String conjunto = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		
            try{
                Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(parser.Caracteres),conjunto));
                parser.Caracteres.clear();
                parser.contCon++;
            }catch(Exception e){
                System.err.println("Error de Conjuntos: " + e);
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("CUERPO",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // CONJUNTO ::= ASCII TKColocho ASCII 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String b = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
    try{
        int inicio;
        int fin;
        if (a == "\\n"){
            inicio = 10;
        } else if (a == "\\'"){
            inicio = 39;
        } else if (a == "\\\""){
            inicio = 34;
        } else {
            inicio = (int)a.charAt(0);
        }
        if (b == "\\n"){
            fin = 10;
        } else if (b == "\\'"){
            fin = 39;
        } else if (b == "\\\""){
            fin = 34;
        } else {
            fin = (int)b.charAt(0);
        }
        for (int i = inicio; i <= fin; i++){
            char temp = (char)i;
            String caracter = String.valueOf(temp);
            parser.Caracteres.add(caracter);
        }
    }catch(Exception e){
        System.err.println("Equis de: " + e);
    }

              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONJUNTO",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // CONJUNTO ::= CONJUNTOLARGO 
            {
              String RESULT =null;
		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONJUNTO",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // CONJUNTOLARGO ::= CONJUNTOLARGO TKComa ASCII 
            {
              String RESULT =null;
		int lexemaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lexemaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String lexema = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
    parser.Caracteres.add(lexema);

              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONJUNTOLARGO",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // CONJUNTOLARGO ::= ASCII 
            {
              String RESULT =null;
		int lexemaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lexemaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String lexema = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    parser.Caracteres.add(lexema);
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("CONJUNTOLARGO",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // ASCII ::= identificador 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ASCII ::= C33 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ASCII ::= C35 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // ASCII ::= C36 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // ASCII ::= TKPorcentaje 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // ASCII ::= C38 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // ASCII ::= C40 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // ASCII ::= C41 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // ASCII ::= TKAsterisco 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // ASCII ::= TKMas 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // ASCII ::= TKComa 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // ASCII ::= TKGuion 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // ASCII ::= TKPunto 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // ASCII ::= C47 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // ASCII ::= entero 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // ASCII ::= TKDosPuntos 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // ASCII ::= TKPuntoComa 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // ASCII ::= C60 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // ASCII ::= C61 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // ASCII ::= TKMayor 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // ASCII ::= TKInterrogacion 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // ASCII ::= C64 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // ASCII ::= C91 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // ASCII ::= C93 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // ASCII ::= C94 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // ASCII ::= C95 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // ASCII ::= C96 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // ASCII ::= TKParA 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // ASCII ::= TKBarra 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // ASCII ::= TKParC 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // ASCII ::= caracterespecial 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		RESULT = a;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ASCII",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // EXPRESION ::= identificador TKGuion TKMayor ARBOL TKPuntoComa 
            {
              String RESULT =null;
		int nombreleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int nombreright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String nombre = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo valor = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                //PARA EL CALCULO DE PRIMEROS
                int[] primeros1 = new int[1];
                primeros1[0] = parser.num;
                //PARA EL CALCULO DE ULTIMOS
                int[] ultimos1 = new int[1];
                ultimos1[0] = parser.num;
                //CREAMOS EL NODO
                Nodo fin = new Nodo(null, null, "#", parser.contId,parser.num, "N", primeros1, ultimos1);
                //CALCULO DE SIGUIENTES
                TablaSiguientes elemento = new TablaSiguientes(parser.num, null, "#");
                if (parser.ListaSiguientes == null){
                    ListaSiguientes = new ArrayList<TablaSiguientes>();
                    parser.ListaSiguientes.add(elemento);
                } else {
                    parser.ListaSiguientes.add(elemento);
                }
                parser.contId++;

                //PARA EL CALCULO DE PRIMEROS
                int [] primeros;
                if (valor.anulable == "A"){
                    primeros = new int[valor.primeros.length + fin.primeros.length];
                    int j = 0;
                    for (int i = 0; i < primeros.length; i++){
                        if (i < valor.primeros.length){
                            primeros[i] = valor.primeros[i];
                        } else {
                            primeros[i] = fin.primeros[j];
                            j++;
                        }
                    }
                } else {
                    primeros = valor.primeros;
                }
                //PARA EL CALCULO DE ULTIMOS
                int [] ultimos;
                if (fin.anulable == "A"){
                    ultimos = new int[valor.ultimos.length + fin.ultimos.length];
                    int j = 0;
                    for (int i = 0; i < ultimos.length; i++){
                        if (i < valor.ultimos.length){
                            ultimos[i] = valor.ultimos[i];
                        } else {
                            ultimos[i] = fin.ultimos[j];
                            j++;
                        }
                    }
                } else {
                    ultimos = fin.ultimos;
                }
                //PARA EL CALCULO DE ANULABLES
                String anulable;
                if (fin.anulable == "A" && valor.anulable == "A"){
                    anulable = "A";
                } else {
                    anulable = "N";
                }
                //CREAMOS EL NODO
                Nodo raiz = new Nodo(valor, fin, ".", parser.contId,0, anulable, primeros, ultimos);
                parser.Raiz = raiz;
                
                //CALCULO DE SIGUIENTES
                int[] ultimosC1 = valor.ultimos;
                int[] primerosC2 = fin.primeros;
                for (int i = 0; i < ultimosC1.length; i++){
                    //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                    int temp = ultimosC1[i];
                    for (int j = 0; j < primerosC2.length; j++){
                        int nuevo = primerosC2[j];
                        if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                            ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                        }
                    }
                }

                graficarArbol(raiz, nombre);
                graficarSiguientes(nombre);
                graficarTransiciones(raiz.primeros, nombre);
                graficarAFD(nombre);
                graficarAFND(nombre);
                //ALMACENAMOS LAS TRANSICIONES Y LOS CONJUNTOS
                
                try{
                    int EstadoFinal = -10;
                    for (int i = 0; i < parser.estados.size(); i++){
                        if (parser.estados.get(i).combinacion.contains(ListaSiguientes.size())){
                            EstadoFinal = parser.estados.get(i).S;
                        }
                    }
                Transiciones tempTrans = new Transiciones(parser.Transiciones, nombre, EstadoFinal, new ArrayList<>(parser.conjuntos));
                Application.App.ListaTransiciones.add(tempTrans);
                }catch(Exception e){
                    System.err.println("Error de Transiciones: " + e);
                }

                parser.num = 1;
                parser.ListaSiguientes.clear();

              CUP$parser$result = parser.getSymbolFactory().newSymbol("EXPRESION",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // EXPRESION ::= EXPRESION identificador TKGuion TKMayor ARBOL TKPuntoComa 
            {
              String RESULT =null;
		int nombreleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int nombreright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String nombre = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int valorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo valor = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                //PARA EL CALCULO DE PRIMEROS
                int[] primeros1 = new int[1];
                primeros1[0] = parser.num;
                //PARA EL CALCULO DE ULTIMOS
                int[] ultimos1 = new int[1];
                ultimos1[0] = parser.num;
                //CREAMOS EL NODO
                Nodo fin = new Nodo(null, null, "#", parser.contId,parser.num, "N", primeros1, ultimos1);
                //CALCULO DE SIGUIENTES
                TablaSiguientes elemento = new TablaSiguientes(parser.num, null, "#");
                if (parser.ListaSiguientes == null){
                    ListaSiguientes = new ArrayList<TablaSiguientes>();
                    parser.ListaSiguientes.add(elemento);
                } else {
                    parser.ListaSiguientes.add(elemento);
                }
                parser.contId++;

                //PARA EL CALCULO DE PRIMEROS
                int [] primeros;
                if (valor.anulable == "A"){
                    primeros = new int[valor.primeros.length + fin.primeros.length];
                    int j = 0;
                    for (int i = 0; i < primeros.length; i++){
                        if (i < valor.primeros.length){
                            primeros[i] = valor.primeros[i];
                        } else {
                            primeros[i] = fin.primeros[j];
                            j++;
                        }
                    }
                } else {
                    primeros = valor.primeros;
                }
                //PARA EL CALCULO DE ULTIMOS
                int [] ultimos;
                if (fin.anulable == "A"){
                    ultimos = new int[valor.ultimos.length + fin.ultimos.length];
                    int j = 0;
                    for (int i = 0; i < ultimos.length; i++){
                        if (i < valor.ultimos.length){
                            ultimos[i] = valor.ultimos[i];
                        } else {
                            ultimos[i] = fin.ultimos[j];
                            j++;
                        }
                    }
                } else {
                    ultimos = fin.ultimos;
                }
                //PARA EL CALCULO DE ANULABLES
                String anulable;
                if (fin.anulable == "A" && valor.anulable == "A"){
                    anulable = "A";
                } else {
                    anulable = "N";
                }
                //CREAMOS EL NODO
                Nodo raiz = new Nodo(valor, fin, ".", parser.contId,0, anulable, primeros, ultimos);
                parser.Raiz = raiz;
                
                //CALCULO DE SIGUIENTES
                int[] ultimosC1 = valor.ultimos;
                int[] primerosC2 = fin.primeros;
                for (int i = 0; i < ultimosC1.length; i++){
                    //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                    int temp = ultimosC1[i];
                    for (int j = 0; j < primerosC2.length; j++){
                        int nuevo = primerosC2[j];
                        if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                            ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                        }
                    }
                }

                graficarArbol(raiz, nombre);
                graficarSiguientes(nombre);
                graficarTransiciones(raiz.primeros, nombre);
                graficarAFD(nombre);
                graficarAFND(nombre);
                //ALMACENAMOS LAS TRANSICIONES Y LOS CONJUNTOS
                
                try{
                    int EstadoFinal = -10;
                    for (int i = 0; i < parser.estados.size(); i++){
                        if (parser.estados.get(i).combinacion.contains(ListaSiguientes.size())){
                            EstadoFinal = parser.estados.get(i).S;
                        }
                    }
                Transiciones tempTrans = new Transiciones(parser.Transiciones, nombre, EstadoFinal, new ArrayList<>(parser.conjuntos));
                Application.App.ListaTransiciones.add(tempTrans);
                }catch(Exception e){
                    System.err.println("Error de Transiciones: " + e);
                }

                parser.num = 1;
                parser.ListaSiguientes.clear();
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("EXPRESION",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // ARBOL ::= TKPunto ARBOL ARBOL 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo b = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //PARA EL CALCULO DE PRIMEROS
            int [] primeros;
            if (a.anulable == "A"){
                primeros = new int[a.primeros.length + b.primeros.length];
                int j = 0;
                for (int i = 0; i < primeros.length; i++){
                    if (i < a.primeros.length){
                        primeros[i] = a.primeros[i];
                    } else {
                        primeros[i] = b.primeros[j];
                        j++;
                    }
                }
            } else {
                primeros = a.primeros;
            }

            //PARA EL CALCULO DE ULTIMOS
            int [] ultimos;
            if (b.anulable == "A"){
                ultimos = new int[a.ultimos.length + b.ultimos.length];
                int j = 0;
                for (int i = 0; i < ultimos.length; i++){
                    if (i < a.ultimos.length){
                        ultimos[i] = a.ultimos[i];
                    } else {
                        ultimos[i] = b.ultimos[j];
                        j++;
                    }
                }
            } else {
                ultimos = b.ultimos;
            }
            
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if (a.anulable == "A" && b.anulable == "A"){
                anulable = "A";
            } else {
                anulable = "N";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,b,".",parser.contId,0, anulable, primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC2 = b.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC2.length; j++){
                    int nuevo = primerosC2[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ARBOL",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // ARBOL ::= TKBarra ARBOL ARBOL 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo b = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[a.primeros.length + b.primeros.length];
            int j = 0;
            for (int i = 0; i < primeros.length; i++){
                if (i < a.primeros.length){
                    primeros[i] = a.primeros[i];
                } else {
                    primeros[i] = b.primeros[j];
                    j++;
                }
            }
            //CALCULOS DE ULTIMOS
            int[] ultimos = new int[a.ultimos.length + b.ultimos.length];
            j = 0;
            for (int i = 0; i < ultimos.length; i++){
                if (i < a.ultimos.length){
                    ultimos[i] = a.ultimos[i];
                } else {
                    ultimos[i] = b.ultimos[j];
                    j++;
                }
            }
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if (a.anulable == "A" || b.anulable == "A"){
                anulable = "A";
            } else {
                anulable = "N";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,b,"\\|",parser.contId,0, anulable, primeros, ultimos);
            parser.contId++;
            RESULT = NuevoPadre;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ARBOL",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // ARBOL ::= TKAsterisco ARBOL 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //CALCULOS DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"*",parser.contId,0, "A", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC1 = a.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC1.length; j++){
                    int nuevo = primerosC1[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ARBOL",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // ARBOL ::= TKMas ARBOL 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if(a.anulable == "N"){
                anulable = "N";
            } else {
                anulable = "A";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"+",parser.contId,0, anulable, primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC1 = a.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC1.length; j++){
                    int nuevo = primerosC1[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ARBOL",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // ARBOL ::= TKInterrogacion ARBOL 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"?",parser.contId,0, "A", primeros, ultimos);
            parser.contId++;
            RESULT = NuevoPadre;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ARBOL",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // ARBOL ::= HOJAS 
            {
              Nodo RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Nodo a = (Nodo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = a;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("ARBOL",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // HOJAS ::= TKParA identificador TKParC 
            {
              Nodo RESULT =null;
		int val0left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int val0right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String val0 = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int val1left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int val1right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String val1 = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,val0+val+val1,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, val);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //ITERAMOS
            parser.contId++;
            parser.num++;
            RESULT = NuevaHoja;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("HOJAS",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // HOJAS ::= caracterespecial 
            {
              Nodo RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,val,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, val);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //INGRESAMOS A LOS CONJUNTOS
            String cadena = val.replace("\\", "");
            List<String> lista = new ArrayList<String>();
            lista.add(cadena);
            Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(lista), val));
            //ITERAMOS
            parser.contId++;
            parser.num++;
            parser.contCon++;
            RESULT = NuevaHoja;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("HOJAS",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // HOJAS ::= cadena 
            {
              Nodo RESULT =null;
		int valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String val = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            String caracter = val.replace("\"", "");
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,caracter,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, caracter);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //INGRESAMOS A LOS CONJUNTOS
            List<String> lista = new ArrayList<String>();
            lista.add(caracter);
            Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(lista), caracter));
            //ITERAMOS
            parser.contId++;
            parser.num++;
            parser.contCon++;
            RESULT = NuevaHoja;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("HOJAS",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // DEFINICION ::= identificador TKDosPuntos cadena TKPuntoComa 
            {
              String RESULT =null;
		int nombreleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int nombreright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String nombre = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int lexemaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lexemaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String lexema = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
    try{
        Application.App.ListaCadenas.add(new Cadena(lexema, nombre));
    }catch(Exception e){
        System.err.println("Error de cadenas: " + e);
    }

              CUP$parser$result = parser.getSymbolFactory().newSymbol("DEFINICION",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // DEFINICION ::= DEFINICION identificador TKDosPuntos cadena TKPuntoComa 
            {
              String RESULT =null;
		int nombreleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int nombreright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String nombre = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int lexemaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lexemaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String lexema = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                try{
                    Application.App.ListaCadenas.add(new Cadena(lexema, nombre));
                }catch(Exception e){
                    System.err.println("Error de cadenas: " + e);
                }
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("DEFINICION",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number "+CUP$parser$act_num+"found in internal parse table");

        }
    } /* end of method */

  /** Method splitting the generated action code into several parts. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
              return CUP$parser$do_action_part00000000(
                               CUP$parser$act_num,
                               CUP$parser$parser,
                               CUP$parser$stack,
                               CUP$parser$top);
    }
}

}
