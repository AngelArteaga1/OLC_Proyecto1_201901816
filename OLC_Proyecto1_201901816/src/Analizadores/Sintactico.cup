package Analizadores;
import java_cup.runtime.*;
import Application.*;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

parser code
{:  
    public static int contId=1;
    public static Nodo Raiz;
    public static int num = 1;
    public static int contCon = 0;
    public static int contEs = 0;
    public static List<TablaSiguientes> ListaSiguientes;
    public static List<Estado> estados;
    public static List<Integer> ListaAuxiliar;
    public static int[][] Transiciones;
    public static List<String> conjuntos;

    public static boolean Equals(List<Integer> lista1, List<Integer> lista2){
        if (lista1.size() != lista2.size()){
            return false;
        } else {
            for (int i = 0; i < lista1.size(); i++){
                if (lista1.get(i) != lista2.get(i)){
                    return false;
                }
            }
        }
        return true;
    }

    public static void CrearEstados(Estado S){
        boolean encontrado = false;
        for (int i = 0; i < S.combinacion.size(); i++){
            int aux = S.combinacion.get(i);
            //VALIDAR SI LA CONBINACION ES LA MISMA
            for ( int j = 0; j < estados.size(); j++){
                if (Equals(estados.get(j).combinacion, ListaSiguientes.get(aux-1).siguientes) == true){
                    encontrado = true;
                }
            }
            if (encontrado == false){
                Estado nuevo = new Estado(contEs, ListaSiguientes.get(aux-1).siguientes);
                estados.add(nuevo);
                contEs++;
                CrearEstados(nuevo);
            }
            encontrado = false;
        }
    }

    public static void graficarTransiciones(int[] anteriores, String nombre){
        System.out.println("ESTOS SON LOS ESTADOS QUE LOGRÉ CREAR:");
        //PASAMOS EL ARRAY A UNA LISTA
        contEs = 0;
        List<Integer> anterioresList = new ArrayList<Integer>();
        ListaAuxiliar = new ArrayList<Integer>();
        for (int i = 0; i < anteriores.length; i++){
            anterioresList.add(anteriores[i]);
        }
        estados = new ArrayList<Estado>();
        Estado inicial = new Estado(contEs, anterioresList);
        estados.add(inicial);
        contEs++;
        //CREAMOS LOS LOS POSIBLES ESTADOS
        CrearEstados(inicial);
        for (int i = 0; i < estados.size(); i++){
            System.out.println(estados.get(i).S + ", " + estados.get(i).combinacion);
        }

        //CREAMOS LA LISTA DE CONJUNTOS
        conjuntos = new ArrayList<String>();
        for (int i = 0; i < ListaSiguientes.size(); i++){
            if (conjuntos.contains(ListaSiguientes.get(i).valor) == false){
                conjuntos.add(ListaSiguientes.get(i).valor);
            }
        }
        System.out.println(conjuntos);

        //CREAMOS LA MATRIZ DE TRANSICIONES
        Transiciones = new int[estados.size()][conjuntos.size()];
        for (int i = 0; i < estados.size(); i++){
            for  ( int j = 0; j < conjuntos.size(); j++){
                Transiciones[i][j] = -1;
            }
        }
        //INGRESAMOS LOS DATOS A LA MATRIZ
        
        try{
            //recorremos la lista de estados encontrados
            for (int i = 0; i < estados.size(); i++){
                System.out.println("***********************************************");
                System.out.println("EMPIEZO A RECORRER ESTADO: " + estados.get(i).S);
                //recorremos las combinaciones del estado actual
                for (int j = 0; j < estados.get(i).combinacion.size(); j++){
                    System.out.println("EMPIEZO A RECORRER COMBINACION: " + estados.get(i).combinacion.get(j));
                    //obtenemos el indice de esa combinacion
                    int indice = estados.get(i).combinacion.get(j);
                    //obtenemos el string del conjunto de ese indice
                    String conjunto = GetCadenaConjunto(indice);
                    System.out.println("ESTE ES EL CONJUNTO DE ESTA COMBINACION: " + conjunto);
                    //recorreremos la lista de estados nuevamente
                    for (int k = 0; k < estados.size(); k++){
                        //sera igual al estado que tenga la misma combinacion para obtener el estado
                        if (Equals(estados.get(k).combinacion, ListaSiguientes.get(indice - 1).siguientes)){
                            System.out.println("LOS SIGUIENTES DE ESE CONJUNTO SON: " + ListaSiguientes.get(indice-1).siguientes);
                            Transiciones[i][GetConjunto(conjunto)] = estados.get(k).S;
                        }
                    }
                }
            }

        }catch(Exception e){
            System.err.println(e);
        }

        //IMPRIMIENDO LA MATRIZ
        for (int i = 0; i < estados.size(); i++){
            System.out.println("");
            for  ( int j = 0; j < conjuntos.size(); j++){
                System.out.print(Transiciones[i][j] + ", ");
            }
        }

        //EMPEZAMOS A GRAFICAR
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("Transiciones/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("tbl [");
            pw.println("shape=plaintext");
            pw.println("label=<");
            pw.println("<TABLE border=\"10\" cellspacing=\"10\" cellpadding=\"10\" style=\"rounded\" bgcolor=\"/rdylgn11/1:/rdylgn11/11\" gradientangle=\"315\">");
            //PARA CREAR LA PRIMERA FILA
            pw.println("<TR>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/6:/rdylgn11/9\">Estados</TD>");
            for (int i = 0; i < conjuntos.size() - 1; i++){
                pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/2:/rdylgn11/3\">" + conjuntos.get(i) + "</TD>");
            }
            pw.println("</TR>");
            //PARA CREAR TODAS LAS SITUACIONES
            for (int i = 0; i < estados.size() - 1; i++){
                pw.println("<TR>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/4:/rdylgn11/5\" gradientangle=\"270\">S" + estados.get(i).S + "</TD>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/3:/rdylgn11/9\" gradientangle=\"270\">" + estados.get(i).combinacion + "</TD>");
                for (int j = 0; j < conjuntos.size() - 1; j++){
                    if (Transiciones[i][j] == -1){
                        pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">---</TD>");
                    } else {
                        pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">S" + Transiciones[i][j] + "</TD>");
                    }
                }
                pw.println("</TR>");
            }

            pw.println("</TABLE>");
            pw.println(">];");
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }



    }

    public static String GetCadenaConjunto(int indice){
        //System.out.println("**********************************************************************");
        //System.out.println("INDICE: " + indice + " VALOR: " + ListaSiguientes.get(indice - 1).valor);
        return ListaSiguientes.get(indice - 1).valor;
    }

    public static int GetConjunto (String conjunto){
        //System.out.println("*********************************************************************");
        int indice = -1;
        for (int i = 0; i < conjuntos.size(); i++){
            //System.out.println(conjuntos.get(i) + "<->" + conjunto);
            if ((conjuntos.get(i)).contains(conjunto) || conjunto.contains(conjuntos.get(i))){
                //System.out.println("LO ENCONTRE PAPA");
                return i;
            }
        }
        System.out.println("CONJUNTO: " + conjunto + " INDICE: " + indice);
        return indice;
    }

    public static void graficarSiguientes(String nombre){
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("siguientes/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("tbl [");
            pw.println("shape=plaintext");
            pw.println("label=<");
            pw.println("<TABLE border=\"10\" cellspacing=\"10\" cellpadding=\"10\" style=\"rounded\" bgcolor=\"/rdylgn11/1:/rdylgn11/11\" gradientangle=\"315\">");
            pw.println("<TR>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/6:/rdylgn11/9\">Simbolos</TD>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/9:/rdylgn11/11\">Siguientes</TD>");
            pw.println("</TR>");

            for (int i = 0; i < ListaSiguientes.size(); i++){
                pw.println("<TR>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/4:/rdylgn11/5\" gradientangle=\"270\">" + ListaSiguientes.get(i).id + "</TD>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/3:/rdylgn11/9\" gradientangle=\"270\">" + ListaSiguientes.get(i).valor + "</TD>");
                pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">" + ListaSiguientes.get(i).siguientes + "</TD>");
                pw.println("</TR>");
            }

            pw.println("</TABLE>");
            pw.println(">];");
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
    }

    public static void graficarArbol(Nodo act, String nombre){

        System.out.println("****************************************************");
        System.out.println("Tamanio de la lista es de: " + ListaSiguientes.size());
        for (int i = 0; i < ListaSiguientes.size(); i++) {
            if (ListaSiguientes.get(i).siguientes.size() == 0){
                System.out.println(ListaSiguientes.get(i).id + " " + ListaSiguientes.get(i).valor);
            } else {
                System.out.println(ListaSiguientes.get(i).id + ", " + ListaSiguientes.get(i).valor + ", " + ListaSiguientes.get(i).siguientes);
            }
            
        }

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("arboles/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            //System.out.println("digraph G{");
            //data = "digraph G{\n";
            pw.println("rankdir=UD");
            //System.out.println("rankdir=UD");
            //data = data + "rankdir=UD\n";
            pw.println("node[shape=record]");
            //System.out.println("node[shape=record]");
            //data = data + "node[shape=box]\n";
            pw.println("concentrate=true");
            //System.out.println("concentrate=true");
            //data = data + "concentrate=true\n";
            pw.println(act.getCodigoInterno());
            //System.out.println(act.getCodigoInterno());
            //data = data + act.getCodigoInterno();
            pw.println("}");
            //System.out.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        /*try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "arboles/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "arboles/" + nombre + ".dot";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        } finally {
        }*/
    }
    //-----------------------------------------para errores sintacticos-------------------------------------------------------------------------------------------
    public void syntax_error(Symbol s)
    {
        App.TxtSalida.append("Error en la Línea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador "+s.value + " no reconocido. Se ha recuperado del error.\n" );
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        App.TxtSalida.append("Error en la Línea " + (s.right+1)+ " Columna "+(s.left+1)+". Identificador " +s.value + " no reconocido.\n");
    }
    //-------------------------------------------------------------------------------------------------------------------------------------------------------------
:}

action code {:
:}

// terminal [Tipo] listaterminales;
terminal String TKParA, TKParC, TKComa, TKBarra, TKPunto, TKMas, TKAsterisco, TKPorcentaje, TKPuntoComa, TKInterrogacion, TKColocho;
terminal String TKConj, TKDosPuntos, cadena, caracterespecial, entero, identificador, TKGuion, TKMayor;
terminal String C33, C36, C35, C38, C40, C41, C47, C60, C61, C64, C91, C93, C94, C95, C96; 
// non terminal [Tipo] listanoterminales;
non terminal String INICIO, CUERPO, CONJUNTO, EXPRESION, DEFINICION, ASCII, CONJUNTOLARGO;
non terminal Nodo ARBOL, HOJAS;


start with INICIO;

INICIO ::= TKParA CUERPO EXPRESION TKPorcentaje TKPorcentaje TKPorcentaje TKPorcentaje DEFINICION TKParC {:
    App.TxtSalida.append("El archivo se ha leido correctamente.\n");
:};

CUERPO ::= TKConj TKDosPuntos identificador:conjunto TKGuion TKMayor CONJUNTO TKPuntoComa{:
    parser.contCon++;
:}
        | CUERPO TKConj TKDosPuntos identificador:conjunto TKGuion TKMayor CONJUNTO TKPuntoComa{:
            parser.contCon++;
        :};

CONJUNTO ::= ASCII TKColocho ASCII{::}
            | CONJUNTOLARGO{::};

CONJUNTOLARGO ::= CONJUNTOLARGO TKComa ASCII{::}
                | ASCII{::};

ASCII ::= identificador
        | C33
        | C35
        | C36
        | TKPorcentaje
        | C38
        | C40
        | C41
        | TKAsterisco
        | TKMas
        | TKComa
        | TKGuion
        | TKPunto
        | C47
        | entero
        | TKDosPuntos
        | TKPuntoComa
        | C60
        | C61
        | TKMayor
        | TKInterrogacion
        | C64
        | C91
        | C93
        | C94
        | C95
        | C96
        | TKParA
        | TKBarra
        | TKParC
        | caracterespecial
;

EXPRESION ::= identificador:nombre TKGuion TKMayor ARBOL:valor TKPuntoComa{:
                //PARA EL CALCULO DE PRIMEROS
                int[] primeros1 = new int[1];
                primeros1[0] = parser.num;
                //PARA EL CALCULO DE ULTIMOS
                int[] ultimos1 = new int[1];
                ultimos1[0] = parser.num;
                //CREAMOS EL NODO
                Nodo fin = new Nodo(null, null, "#", parser.contId,parser.num, "N", primeros1, ultimos1);
                //CALCULO DE SIGUIENTES
                TablaSiguientes elemento = new TablaSiguientes(parser.num, null, "#");
                if (parser.ListaSiguientes == null){
                    ListaSiguientes = new ArrayList<TablaSiguientes>();
                    parser.ListaSiguientes.add(elemento);
                } else {
                    parser.ListaSiguientes.add(elemento);
                }
                parser.contId++;

                //PARA EL CALCULO DE PRIMEROS
                int [] primeros;
                if (valor.anulable == "A"){
                    primeros = new int[valor.primeros.length + fin.primeros.length];
                    int j = 0;
                    for (int i = 0; i < primeros.length; i++){
                        if (i < valor.primeros.length){
                            primeros[i] = valor.primeros[i];
                        } else {
                            primeros[i] = fin.primeros[j];
                            j++;
                        }
                    }
                } else {
                    primeros = valor.primeros;
                }
                //PARA EL CALCULO DE ULTIMOS
                int [] ultimos;
                if (fin.anulable == "A"){
                    ultimos = new int[valor.ultimos.length + fin.ultimos.length];
                    int j = 0;
                    for (int i = 0; i < ultimos.length; i++){
                        if (i < valor.ultimos.length){
                            ultimos[i] = valor.ultimos[i];
                        } else {
                            ultimos[i] = fin.ultimos[j];
                            j++;
                        }
                    }
                } else {
                    ultimos = fin.ultimos;
                }
                //PARA EL CALCULO DE ANULABLES
                String anulable;
                if (fin.anulable == "A" && valor.anulable == "A"){
                    anulable = "A";
                } else {
                    anulable = "N";
                }
                //CREAMOS EL NODO
                Nodo raiz = new Nodo(valor, fin, ".", parser.contId,0, anulable, primeros, ultimos);
                parser.Raiz = raiz;
                
                //CALCULO DE SIGUIENTES
                int[] ultimosC1 = valor.ultimos;
                int[] primerosC2 = fin.primeros;
                for (int i = 0; i < ultimosC1.length; i++){
                    //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                    int temp = ultimosC1[i];
                    for (int j = 0; j < primerosC2.length; j++){
                        int nuevo = primerosC2[j];
                        if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                            ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                        }
                    }
                }

                graficarArbol(raiz, nombre);
                graficarSiguientes(nombre);
                graficarTransiciones(raiz.primeros, nombre);
                parser.num = 1;
                parser.ListaSiguientes.clear();
:}
            | EXPRESION identificador:nombre TKGuion TKMayor ARBOL:valor TKPuntoComa{:
                //PARA EL CALCULO DE PRIMEROS
                int[] primeros1 = new int[1];
                primeros1[0] = parser.num;
                //PARA EL CALCULO DE ULTIMOS
                int[] ultimos1 = new int[1];
                ultimos1[0] = parser.num;
                //CREAMOS EL NODO
                Nodo fin = new Nodo(null, null, "#", parser.contId,parser.num, "N", primeros1, ultimos1);
                //CALCULO DE SIGUIENTES
                TablaSiguientes elemento = new TablaSiguientes(parser.num, null, "#");
                if (parser.ListaSiguientes == null){
                    ListaSiguientes = new ArrayList<TablaSiguientes>();
                    parser.ListaSiguientes.add(elemento);
                } else {
                    parser.ListaSiguientes.add(elemento);
                }
                parser.contId++;

                //PARA EL CALCULO DE PRIMEROS
                int [] primeros;
                if (valor.anulable == "A"){
                    primeros = new int[valor.primeros.length + fin.primeros.length];
                    int j = 0;
                    for (int i = 0; i < primeros.length; i++){
                        if (i < valor.primeros.length){
                            primeros[i] = valor.primeros[i];
                        } else {
                            primeros[i] = fin.primeros[j];
                            j++;
                        }
                    }
                } else {
                    primeros = valor.primeros;
                }
                //PARA EL CALCULO DE ULTIMOS
                int [] ultimos;
                if (fin.anulable == "A"){
                    ultimos = new int[valor.ultimos.length + fin.ultimos.length];
                    int j = 0;
                    for (int i = 0; i < ultimos.length; i++){
                        if (i < valor.ultimos.length){
                            ultimos[i] = valor.ultimos[i];
                        } else {
                            ultimos[i] = fin.ultimos[j];
                            j++;
                        }
                    }
                } else {
                    ultimos = fin.ultimos;
                }
                //PARA EL CALCULO DE ANULABLES
                String anulable;
                if (fin.anulable == "A" && valor.anulable == "A"){
                    anulable = "A";
                } else {
                    anulable = "N";
                }
                //CREAMOS EL NODO
                Nodo raiz = new Nodo(valor, fin, ".", parser.contId,0, anulable, primeros, ultimos);
                parser.Raiz = raiz;
                
                //CALCULO DE SIGUIENTES
                int[] ultimosC1 = valor.ultimos;
                int[] primerosC2 = fin.primeros;
                for (int i = 0; i < ultimosC1.length; i++){
                    //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                    int temp = ultimosC1[i];
                    for (int j = 0; j < primerosC2.length; j++){
                        int nuevo = primerosC2[j];
                        if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                            ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                        }
                    }
                }
                graficarArbol(raiz, nombre);
                graficarSiguientes(nombre);
                graficarTransiciones(raiz.primeros, nombre);
                parser.num = 1;
                parser.ListaSiguientes.clear();
            :};

ARBOL ::= TKPunto ARBOL:a ARBOL:b{:
            //PARA EL CALCULO DE PRIMEROS
            int [] primeros;
            if (a.anulable == "A"){
                primeros = new int[a.primeros.length + b.primeros.length];
                int j = 0;
                for (int i = 0; i < primeros.length; i++){
                    if (i < a.primeros.length){
                        primeros[i] = a.primeros[i];
                    } else {
                        primeros[i] = b.primeros[j];
                        j++;
                    }
                }
            } else {
                primeros = a.primeros;
            }

            //PARA EL CALCULO DE ULTIMOS
            int [] ultimos;
            if (b.anulable == "A"){
                ultimos = new int[a.ultimos.length + b.ultimos.length];
                int j = 0;
                for (int i = 0; i < ultimos.length; i++){
                    if (i < a.ultimos.length){
                        ultimos[i] = a.ultimos[i];
                    } else {
                        ultimos[i] = b.ultimos[j];
                        j++;
                    }
                }
            } else {
                ultimos = b.ultimos;
            }
            
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if (a.anulable == "A" && b.anulable == "A"){
                anulable = "A";
            } else {
                anulable = "N";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,b,".",parser.contId,0, anulable, primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC2 = b.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC2.length; j++){
                    int nuevo = primerosC2[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
:}
        | TKBarra ARBOL:a ARBOL:b{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[a.primeros.length + b.primeros.length];
            int j = 0;
            for (int i = 0; i < primeros.length; i++){
                if (i < a.primeros.length){
                    primeros[i] = a.primeros[i];
                } else {
                    primeros[i] = b.primeros[j];
                    j++;
                }
            }
            //CALCULOS DE ULTIMOS
            int[] ultimos = new int[a.ultimos.length + b.ultimos.length];
            j = 0;
            for (int i = 0; i < ultimos.length; i++){
                if (i < a.ultimos.length){
                    ultimos[i] = a.ultimos[i];
                } else {
                    ultimos[i] = b.ultimos[j];
                    j++;
                }
            }
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if (a.anulable == "A" || b.anulable == "A"){
                anulable = "A";
            } else {
                anulable = "N";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,b,"\\|",parser.contId,0, anulable, primeros, ultimos);
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | TKAsterisco ARBOL:a{:
            //CALCULOS DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"*",parser.contId,0, "A", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC1 = a.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC1.length; j++){
                    int nuevo = primerosC1[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | TKMas ARBOL:a{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if(a.anulable == "N"){
                anulable = "N";
            } else {
                anulable = "A";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"+",parser.contId,0, anulable, primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC1 = a.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC1.length; j++){
                    int nuevo = primerosC1[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | TKInterrogacion ARBOL:a{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"?",parser.contId,0, "A", primeros, ultimos);
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | HOJAS:a{:
            RESULT = a;
        :};

HOJAS ::= TKParA:val0 identificador:val TKParC:val1{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,val0+val+val1,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, val);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //ITERAMOS
            parser.contId++;
            parser.num++;
            RESULT = NuevaHoja;
        :}
        | caracterespecial:val{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,val,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, val);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //ITERAMOS
            parser.contId++;
            parser.num++;
            parser.contCon++;
            RESULT = NuevaHoja;
        :}
        | cadena:val{:
            String caracter = val.replace("\"", "");
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,caracter,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, caracter);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //ITERAMOS
            parser.contId++;
            parser.num++;
            parser.contCon++;
            RESULT = NuevaHoja;
        :};

DEFINICION ::= identificador TKDosPuntos cadena TKPuntoComa{::}
            | DEFINICION identificador TKDosPuntos cadena TKPuntoComa{::};