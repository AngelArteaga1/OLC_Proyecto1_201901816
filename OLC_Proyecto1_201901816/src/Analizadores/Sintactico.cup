package Analizadores;
import java_cup.runtime.*;
import Application.*;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

parser code
{:  
    public static int contId=1;
    public static Nodo Raiz;
    public static int num = 1;
    public static int contCon = 0;
    public static int contEs = 0;
    public static List<TablaSiguientes> ListaSiguientes;
    public static List<Estado> estados;
    public static List<Integer> ListaAuxiliar;
    public static int[][] Transiciones;
    public static List<String> conjuntos;
    public static List<String> Caracteres = new ArrayList<String>();

    public static void GraficarErrores(){
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("Errores.html");
            pw = new PrintWriter(fichero);
            //EMPEZAMOS EL DOCUMENTO HTML       
            pw.println("<!doctype html>");
            pw.println("<head>");
            pw.println("<meta charset=\"utf-8\">");
            pw.println("<meta name=\"author\" content=\"Angel Arteaga\">");
            pw.println("<meta name=\"descripción\" content=\"Errores de entrada\">");
            pw.println("<title>Errores De Entrada</title>");
            pw.println("</head>");
            pw.println("<style>");
            pw.println("table.GeneratedTable {width: 100%;background-color: #ffffff;border-collapse: collapse;border-width: 2px;border-color: #a2f575;border-style: solid;color: #000000;}");
            pw.println("table.GeneratedTable td, table.GeneratedTable th {border-width: 2px;border-color: #a2f575;border-style: solid;padding: 3px;}");
            pw.println("table.GeneratedTable thead {background-color: #bcf98b;}");
            pw.println("</style>");
            pw.println("<body>");
            pw.println("<table class=\"GeneratedTable\">");
            pw.println("<thead><tr><th>Número #</th><th>Tipo de Error</th><th>Descripción</th><th>Línea</th><th>Columna</th></tr></thead>");
            pw.println("<tbody>");
            //AHORA LA PARTE DINAMICA
            for (int i = 0; i < Application.App.ListaErrores.size(); i++){
                pw.println("<tr>");
                pw.println("<td>" + i +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Tipo +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Descripcion +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Linea +"</td>");
                pw.println("<td>" + Application.App.ListaErrores.get(i).Columna +"</td>");
                pw.println("</tr>");
            }

            pw.println("</tbody>");
            pw.println("</table>");
            pw.println("</body>");
            pw.println("</html>");

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
    }

    public static void graficarAFND(String nombre){

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("afd/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");

            pw.println("rankdir=LR");

            pw.println("node[shape=circle]");

            //Generamos los estados 
            for (int i = 0; i < estados.size() -1; i++){
                if (estados.get(i).combinacion.contains(ListaSiguientes.size())){
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\", shape=doublecircle ];");
                } else {
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\"];");
                } 
            }
            //realizamos las transiciones
            for (int i = 0; i < estados.size() - 1; i++){
                for (int j = 0; j < conjuntos.size() - 1; j++){
                    if (Transiciones[i][j] != -1){
                        String conjunto = conjuntos.get(j);
                        if (conjunto.equals("\\n") || conjunto.equals("\\'")||conjunto.equals("\\\"")){
                            conjunto = conjunto.replace("\\", "\\\\");
                        }
                        pw.println("nodo" + i + "->nodo" + Transiciones[i][j] + " [label = \"" + conjunto + "\"]");
                    }

                }
            }

            pw.println("}");

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "afd/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/AFD/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void graficarAFD(String nombre){

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("afnd/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");

            pw.println("rankdir=LR");

            pw.println("node[shape=circle]");

            //Generamos los estados 
            for (int i = 0; i < estados.size() -1; i++){
                if (estados.get(i).combinacion.contains(ListaSiguientes.size())){
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\", shape=doublecircle ];");
                } else {
                    pw.println("nodo" + estados.get(i).S + " [ label =\"S" + estados.get(i).S + "\"];");
                } 
            }
            //realizamos las transiciones
            int x = 1;
            for (int i = 0; i < estados.size() - 1; i++){
                for (int j = 0; j < conjuntos.size() - 1; j++){
                    if (Transiciones[i][j] != -1){
                        String conjunto = conjuntos.get(j);
                        if (conjunto.equals("\\n") || conjunto.equals("\\'")||conjunto.equals("\\\"")){
                            conjunto = conjunto.replace("\\", "\\\\");
                        }
                        pw.println("nodo" + i + "->SS" + x + " [label = \"" + "ε" + "\"]");
                        pw.println("SS" + x + "->nodo" + Transiciones[i][j] + " [label = \"" + conjunto + "\"]");
                    }
                    x++;
                }
            }

            pw.println("}");

        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "afnd/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/AFND/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static boolean Equals(List<Integer> lista1, List<Integer> lista2){
        if (lista1.size() != lista2.size()){
            return false;
        } else {
            for (int i = 0; i < lista1.size(); i++){
                if (lista1.get(i) != lista2.get(i)){
                    return false;
                }
            }
        }
        return true;
    }

    public static void CrearEstados(Estado S){
        boolean encontrado = false;
        for (int i = 0; i < S.combinacion.size(); i++){
            int aux = S.combinacion.get(i);
            //VALIDAR SI LA CONBINACION ES LA MISMA
            for ( int j = 0; j < estados.size(); j++){
                if (Equals(estados.get(j).combinacion, ListaSiguientes.get(aux-1).siguientes) == true){
                    encontrado = true;
                }
            }
            if (encontrado == false){
                Estado nuevo = new Estado(contEs, ListaSiguientes.get(aux-1).siguientes);
                estados.add(nuevo);
                contEs++;
                CrearEstados(nuevo);
            }
            encontrado = false;
        }
    }

    public static void graficarTransiciones(int[] anteriores, String nombre){
        System.out.println("ESTOS SON LOS ESTADOS QUE LOGRÉ CREAR:");
        //PASAMOS EL ARRAY A UNA LISTA
        contEs = 0;
        List<Integer> anterioresList = new ArrayList<Integer>();
        ListaAuxiliar = new ArrayList<Integer>();
        for (int i = 0; i < anteriores.length; i++){
            anterioresList.add(anteriores[i]);
        }
        estados = new ArrayList<Estado>();
        Estado inicial = new Estado(contEs, anterioresList);
        estados.add(inicial);
        contEs++;
        //CREAMOS LOS LOS POSIBLES ESTADOS
        CrearEstados(inicial);
        for (int i = 0; i < estados.size(); i++){
            System.out.println(estados.get(i).S + ", " + estados.get(i).combinacion);
        }

        //CREAMOS LA LISTA DE CONJUNTOS
        conjuntos = new ArrayList<String>();
        for (int i = 0; i < ListaSiguientes.size(); i++){
            if (conjuntos.contains(ListaSiguientes.get(i).valor) == false){
                conjuntos.add(ListaSiguientes.get(i).valor);
            }
        }
        System.out.println(conjuntos);

        //CREAMOS LA MATRIZ DE TRANSICIONES
        Transiciones = new int[estados.size()][conjuntos.size()];
        for (int i = 0; i < estados.size(); i++){
            for  ( int j = 0; j < conjuntos.size(); j++){
                Transiciones[i][j] = -1;
            }
        }

        //INGRESAMOS LOS DATOS A LA MATRIZ
        try{
            //recorremos la lista de estados encontrados
            for (int i = 0; i < estados.size(); i++){
                //recorremos las combinaciones del estado actual
                for (int j = 0; j < estados.get(i).combinacion.size(); j++){
                    //obtenemos el indice de esa combinacion
                    int indice = estados.get(i).combinacion.get(j);
                    //obtenemos el string del conjunto de ese indice
                    String conjunto = GetCadenaConjunto(indice);
                    //recorreremos la lista de estados nuevamente
                    for (int k = 0; k < estados.size(); k++){
                        //sera igual al estado que tenga la misma combinacion para obtener el estado
                        if (Equals(estados.get(k).combinacion, ListaSiguientes.get(indice - 1).siguientes)){
                            Transiciones[i][GetConjunto(conjunto)] = estados.get(k).S;
                        }
                    }
                }
            }

        }catch(Exception e){
            System.err.println(e);
        }

        //IMPRIMIENDO LA MATRIZ
        for (int i = 0; i < estados.size(); i++){
            System.out.println("");
            for  ( int j = 0; j < conjuntos.size(); j++){
                System.out.print(Transiciones[i][j] + ", ");
            }
        }

        //EMPEZAMOS A GRAFICAR
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("Transiciones/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("tbl [");
            pw.println("shape=plaintext");
            pw.println("label=<");
            pw.println("<TABLE border=\"10\" cellspacing=\"10\" cellpadding=\"10\" style=\"rounded\" bgcolor=\"/rdylgn11/1:/rdylgn11/11\" gradientangle=\"315\">");
            //PARA CREAR LA PRIMERA FILA
            pw.println("<TR>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/6:/rdylgn11/9\">Estados</TD>");
            for (int i = 0; i < conjuntos.size() - 1; i++){
                pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/2:/rdylgn11/3\">" + conjuntos.get(i) + "</TD>");
            }
            pw.println("</TR>");
            //PARA CREAR TODAS LAS SITUACIONES
            for (int i = 0; i < estados.size() - 1; i++){
                pw.println("<TR>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/4:/rdylgn11/5\" gradientangle=\"270\">S" + estados.get(i).S + "</TD>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/3:/rdylgn11/9\" gradientangle=\"270\">" + estados.get(i).combinacion + "</TD>");
                for (int j = 0; j < conjuntos.size() - 1; j++){
                    if (Transiciones[i][j] == -1){
                        pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">---</TD>");
                    } else {
                        pw.println("<TD border=\"3\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">S" + Transiciones[i][j] + "</TD>");
                    }
                }
                pw.println("</TR>");
            }

            pw.println("</TABLE>");
            pw.println(">];");
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "transiciones/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/Transiciones/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }


    }

    public static String GetCadenaConjunto(int indice){
        //System.out.println("**********************************************************************");
        //System.out.println("INDICE: " + indice + " VALOR: " + ListaSiguientes.get(indice - 1).valor);
        return ListaSiguientes.get(indice - 1).valor;
    }

    public static int GetConjunto (String conjunto){
        //System.out.println("*********************************************************************");
        int indice = -1;
        for (int i = 0; i < conjuntos.size(); i++){
            //System.out.println(conjuntos.get(i) + "<->" + conjunto);
            if ((conjuntos.get(i)).contains(conjunto) || conjunto.contains(conjuntos.get(i))){
                //System.out.println("LO ENCONTRE PAPA");
                return i;
            }
        }
        System.out.println("CONJUNTO: " + conjunto + " INDICE: " + indice);
        return indice;
    }

    public static void graficarSiguientes(String nombre){
        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("siguientes/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("tbl [");
            pw.println("shape=plaintext");
            pw.println("label=<");
            pw.println("<TABLE border=\"10\" cellspacing=\"10\" cellpadding=\"10\" style=\"rounded\" bgcolor=\"/rdylgn11/1:/rdylgn11/11\" gradientangle=\"315\">");
            pw.println("<TR>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/6:/rdylgn11/9\">Simbolos</TD>");
            pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/9:/rdylgn11/11\">Siguientes</TD>");
            pw.println("</TR>");

            for (int i = 0; i < ListaSiguientes.size(); i++){
                pw.println("<TR>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/4:/rdylgn11/5\" gradientangle=\"270\">" + ListaSiguientes.get(i).id + "</TD>");
                pw.println("<TD border=\"3\" bgcolor=\"/rdylgn11/3:/rdylgn11/9\" gradientangle=\"270\">" + ListaSiguientes.get(i).valor + "</TD>");
                pw.println("<TD border=\"3\" colspan=\"2\"  bgcolor=\"/rdylgn11/1:/rdylgn11/8\">" + ListaSiguientes.get(i).siguientes + "</TD>");
                pw.println("</TR>");
            }

            pw.println("</TABLE>");
            pw.println(">];");
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "siguientes/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/Siguientes/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void graficarArbol(Nodo act, String nombre){

        FileWriter fichero = null;
        PrintWriter pw = null;
        try {
            fichero = new FileWriter("arboles/" + nombre + ".dot");
            pw = new PrintWriter(fichero);
            pw.println("digraph G{");
            pw.println("rankdir=UD");
            pw.println("node[shape=record]");
            pw.println("concentrate=true");
            pw.println(act.getCodigoInterno());
            pw.println("}");
        } catch (Exception e) {
            System.out.println("error, no se realizo el archivo");
        } finally {
            try {
                if (null != fichero) {
                    fichero.close();
                }
            } catch (Exception e2) {
                e2.printStackTrace();
            }
        }
        //para compilar el archivo dot y obtener la imagen
        try {
            //dirección doonde se ecnuentra el compilador de graphviz
            String dotPath = "C:\\Program Files\\Graphviz\\bin\\dot.exe";
            //dirección del archivo dot
            String fileInputPath = "arboles/" + nombre + ".dot";
            //dirección donde se creara la magen
            String fileOutputPath = "Graficas/arboles/" + nombre + ".jpg";
            //tipo de conversón
            String tParam = "-Tjpg";
            String tOParam = "-o";

            String[] cmd = new String[5];
            cmd[0] = dotPath;
            cmd[1] = tParam;
            cmd[2] = fileInputPath;
            cmd[3] = tOParam;
            cmd[4] = fileOutputPath;

            Runtime rt = Runtime.getRuntime();

            rt.exec(cmd);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
    //-----------------------------------------para errores sintacticos-------------------------------------------------------------------------------------------
    public void syntax_error(Symbol s)
    {
        App.TxtSalida.append("Error en la Línea " + (s.right+1) +" Columna "+(s.left+1)+ ". Identificador "+s.value + " no reconocido.\n" );
        Errores err = new Errores("Sintáctico", "El identificador \"" + s.value + "\" no se esperaba.", s.right+1, s.left+1);
        Application.App.ListaErrores.add(err);
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception
    {
        App.TxtSalida.append("Error en la Línea " + (s.right+1)+ " Columna "+(s.left+1)+". Identificador " +s.value + " no reconocido.\n");
        Errores err = new Errores("Sintáctico", "El identificador \"" + s.value + "\" no se esperaba.", s.right+1, s.left+1);
        Application.App.ListaErrores.add(err);
        GraficarErrores();
    }
    //-------------------------------------------------------------------------------------------------------------------------------------------------------------
:}

action code {:
:}

// terminal [Tipo] listaterminales;
terminal String TKParA, TKParC, TKComa, TKBarra, TKPunto, TKMas, TKAsterisco, TKPorcentaje, TKPuntoComa, TKInterrogacion, TKColocho;
terminal String TKConj, TKDosPuntos, cadena, caracterespecial, entero, identificador, TKGuion, TKMayor;
terminal String C33, C36, C35, C38, C40, C41, C47, C60, C61, C64, C91, C93, C94, C95, C96; 
// non terminal [Tipo] listanoterminales;
non terminal String INICIO, CUERPO, CONJUNTO, EXPRESION, DEFINICION, ASCII, CONJUNTOLARGO;
non terminal Nodo ARBOL, HOJAS;


start with INICIO;

INICIO ::= TKParA CUERPO EXPRESION TKPorcentaje TKPorcentaje TKPorcentaje TKPorcentaje DEFINICION TKParC {:
    App.TxtSalida.append("El archivo se ha leido correctamente.\n");
:};

CUERPO ::= TKConj TKDosPuntos identificador:conjunto TKGuion TKMayor CONJUNTO TKPuntoComa{:
    try{
            Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(parser.Caracteres),conjunto));
            parser.Caracteres.clear();
            parser.contCon++;
        }catch(Exception e){
            System.err.println("Error de Conjuntos: " + e);
        }
:}
        | CUERPO TKConj TKDosPuntos identificador:conjunto TKGuion TKMayor CONJUNTO TKPuntoComa{:
            try{
                Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(parser.Caracteres),conjunto));
                parser.Caracteres.clear();
                parser.contCon++;
            }catch(Exception e){
                System.err.println("Error de Conjuntos: " + e);
            }
        :};

CONJUNTO ::= ASCII:a TKColocho ASCII:b{:
    try{
        int inicio;
        int fin;
        if (a == "\\n"){
            inicio = 10;
        } else if (a == "\\'"){
            inicio = 39;
        } else if (a == "\\\""){
            inicio = 34;
        } else {
            inicio = (int)a.charAt(0);
        }
        if (b == "\\n"){
            fin = 10;
        } else if (b == "\\'"){
            fin = 39;
        } else if (b == "\\\""){
            fin = 34;
        } else {
            fin = (int)b.charAt(0);
        }
        for (int i = inicio; i <= fin; i++){
            char temp = (char)i;
            String caracter = String.valueOf(temp);
            parser.Caracteres.add(caracter);
        }
    }catch(Exception e){
        System.err.println("Equis de: " + e);
    }
:}
            | CONJUNTOLARGO{::};

CONJUNTOLARGO ::= CONJUNTOLARGO TKComa ASCII:lexema{:
    parser.Caracteres.add(lexema);
:}
                | ASCII:lexema{:
                    parser.Caracteres.add(lexema);
                :};

ASCII ::= identificador:a{:RESULT = a;:}
        | C33:a{:RESULT = a;:}
        | C35:a{:RESULT = a;:}
        | C36:a{:RESULT = a;:}
        | TKPorcentaje:a{:RESULT = a;:}
        | C38:a{:RESULT = a;:}
        | C40:a{:RESULT = a;:}
        | C41:a{:RESULT = a;:}
        | TKAsterisco:a{:RESULT = a;:}
        | TKMas:a{:RESULT = a;:}
        | TKComa:a{:RESULT = a;:}
        | TKGuion:a{:RESULT = a;:}
        | TKPunto:a{:RESULT = a;:}
        | C47:a{:RESULT = a;:}
        | entero:a{:RESULT = a;:}
        | TKDosPuntos:a{:RESULT = a;:}
        | TKPuntoComa:a{:RESULT = a;:}
        | C60:a{:RESULT = a;:}
        | C61:a{:RESULT = a;:}
        | TKMayor:a{:RESULT = a;:}
        | TKInterrogacion:a{:RESULT = a;:}
        | C64:a{:RESULT = a;:}
        | C91:a{:RESULT = a;:}
        | C93:a{:RESULT = a;:}
        | C94:a{:RESULT = a;:}
        | C95:a{:RESULT = a;:}
        | C96:a{:RESULT = a;:}
        | TKParA:a{:RESULT = a;:}
        | TKBarra:a{:RESULT = a;:}
        | TKParC:a{:RESULT = a;:}
        | caracterespecial:a{:RESULT = a;:}
;

EXPRESION ::= identificador:nombre TKGuion TKMayor ARBOL:valor TKPuntoComa{:
                //PARA EL CALCULO DE PRIMEROS
                int[] primeros1 = new int[1];
                primeros1[0] = parser.num;
                //PARA EL CALCULO DE ULTIMOS
                int[] ultimos1 = new int[1];
                ultimos1[0] = parser.num;
                //CREAMOS EL NODO
                Nodo fin = new Nodo(null, null, "#", parser.contId,parser.num, "N", primeros1, ultimos1);
                //CALCULO DE SIGUIENTES
                TablaSiguientes elemento = new TablaSiguientes(parser.num, null, "#");
                if (parser.ListaSiguientes == null){
                    ListaSiguientes = new ArrayList<TablaSiguientes>();
                    parser.ListaSiguientes.add(elemento);
                } else {
                    parser.ListaSiguientes.add(elemento);
                }
                parser.contId++;

                //PARA EL CALCULO DE PRIMEROS
                int [] primeros;
                if (valor.anulable == "A"){
                    primeros = new int[valor.primeros.length + fin.primeros.length];
                    int j = 0;
                    for (int i = 0; i < primeros.length; i++){
                        if (i < valor.primeros.length){
                            primeros[i] = valor.primeros[i];
                        } else {
                            primeros[i] = fin.primeros[j];
                            j++;
                        }
                    }
                } else {
                    primeros = valor.primeros;
                }
                //PARA EL CALCULO DE ULTIMOS
                int [] ultimos;
                if (fin.anulable == "A"){
                    ultimos = new int[valor.ultimos.length + fin.ultimos.length];
                    int j = 0;
                    for (int i = 0; i < ultimos.length; i++){
                        if (i < valor.ultimos.length){
                            ultimos[i] = valor.ultimos[i];
                        } else {
                            ultimos[i] = fin.ultimos[j];
                            j++;
                        }
                    }
                } else {
                    ultimos = fin.ultimos;
                }
                //PARA EL CALCULO DE ANULABLES
                String anulable;
                if (fin.anulable == "A" && valor.anulable == "A"){
                    anulable = "A";
                } else {
                    anulable = "N";
                }
                //CREAMOS EL NODO
                Nodo raiz = new Nodo(valor, fin, ".", parser.contId,0, anulable, primeros, ultimos);
                parser.Raiz = raiz;
                
                //CALCULO DE SIGUIENTES
                int[] ultimosC1 = valor.ultimos;
                int[] primerosC2 = fin.primeros;
                for (int i = 0; i < ultimosC1.length; i++){
                    //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                    int temp = ultimosC1[i];
                    for (int j = 0; j < primerosC2.length; j++){
                        int nuevo = primerosC2[j];
                        if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                            ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                        }
                    }
                }

                graficarArbol(raiz, nombre);
                graficarSiguientes(nombre);
                graficarTransiciones(raiz.primeros, nombre);
                graficarAFD(nombre);
                graficarAFND(nombre);
                //ALMACENAMOS LAS TRANSICIONES Y LOS CONJUNTOS
                
                try{
                    int EstadoFinal = -10;
                    for (int i = 0; i < parser.estados.size(); i++){
                        if (parser.estados.get(i).combinacion.contains(ListaSiguientes.size())){
                            EstadoFinal = parser.estados.get(i).S;
                        }
                    }
                Transiciones tempTrans = new Transiciones(parser.Transiciones, nombre, EstadoFinal, new ArrayList<>(parser.conjuntos));
                Application.App.ListaTransiciones.add(tempTrans);
                }catch(Exception e){
                    System.err.println("Error de Transiciones: " + e);
                }

                parser.num = 1;
                parser.ListaSiguientes.clear();
:}
            | EXPRESION identificador:nombre TKGuion TKMayor ARBOL:valor TKPuntoComa{:
                //PARA EL CALCULO DE PRIMEROS
                int[] primeros1 = new int[1];
                primeros1[0] = parser.num;
                //PARA EL CALCULO DE ULTIMOS
                int[] ultimos1 = new int[1];
                ultimos1[0] = parser.num;
                //CREAMOS EL NODO
                Nodo fin = new Nodo(null, null, "#", parser.contId,parser.num, "N", primeros1, ultimos1);
                //CALCULO DE SIGUIENTES
                TablaSiguientes elemento = new TablaSiguientes(parser.num, null, "#");
                if (parser.ListaSiguientes == null){
                    ListaSiguientes = new ArrayList<TablaSiguientes>();
                    parser.ListaSiguientes.add(elemento);
                } else {
                    parser.ListaSiguientes.add(elemento);
                }
                parser.contId++;

                //PARA EL CALCULO DE PRIMEROS
                int [] primeros;
                if (valor.anulable == "A"){
                    primeros = new int[valor.primeros.length + fin.primeros.length];
                    int j = 0;
                    for (int i = 0; i < primeros.length; i++){
                        if (i < valor.primeros.length){
                            primeros[i] = valor.primeros[i];
                        } else {
                            primeros[i] = fin.primeros[j];
                            j++;
                        }
                    }
                } else {
                    primeros = valor.primeros;
                }
                //PARA EL CALCULO DE ULTIMOS
                int [] ultimos;
                if (fin.anulable == "A"){
                    ultimos = new int[valor.ultimos.length + fin.ultimos.length];
                    int j = 0;
                    for (int i = 0; i < ultimos.length; i++){
                        if (i < valor.ultimos.length){
                            ultimos[i] = valor.ultimos[i];
                        } else {
                            ultimos[i] = fin.ultimos[j];
                            j++;
                        }
                    }
                } else {
                    ultimos = fin.ultimos;
                }
                //PARA EL CALCULO DE ANULABLES
                String anulable;
                if (fin.anulable == "A" && valor.anulable == "A"){
                    anulable = "A";
                } else {
                    anulable = "N";
                }
                //CREAMOS EL NODO
                Nodo raiz = new Nodo(valor, fin, ".", parser.contId,0, anulable, primeros, ultimos);
                parser.Raiz = raiz;
                
                //CALCULO DE SIGUIENTES
                int[] ultimosC1 = valor.ultimos;
                int[] primerosC2 = fin.primeros;
                for (int i = 0; i < ultimosC1.length; i++){
                    //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                    int temp = ultimosC1[i];
                    for (int j = 0; j < primerosC2.length; j++){
                        int nuevo = primerosC2[j];
                        if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                            ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                        }
                    }
                }

                graficarArbol(raiz, nombre);
                graficarSiguientes(nombre);
                graficarTransiciones(raiz.primeros, nombre);
                graficarAFD(nombre);
                graficarAFND(nombre);
                //ALMACENAMOS LAS TRANSICIONES Y LOS CONJUNTOS
                
                try{
                    int EstadoFinal = -10;
                    for (int i = 0; i < parser.estados.size(); i++){
                        if (parser.estados.get(i).combinacion.contains(ListaSiguientes.size())){
                            EstadoFinal = parser.estados.get(i).S;
                        }
                    }
                Transiciones tempTrans = new Transiciones(parser.Transiciones, nombre, EstadoFinal, new ArrayList<>(parser.conjuntos));
                Application.App.ListaTransiciones.add(tempTrans);
                }catch(Exception e){
                    System.err.println("Error de Transiciones: " + e);
                }

                parser.num = 1;
                parser.ListaSiguientes.clear();
            :};

ARBOL ::= TKPunto ARBOL:a ARBOL:b{:
            //PARA EL CALCULO DE PRIMEROS
            int [] primeros;
            if (a.anulable == "A"){
                primeros = new int[a.primeros.length + b.primeros.length];
                int j = 0;
                for (int i = 0; i < primeros.length; i++){
                    if (i < a.primeros.length){
                        primeros[i] = a.primeros[i];
                    } else {
                        primeros[i] = b.primeros[j];
                        j++;
                    }
                }
            } else {
                primeros = a.primeros;
            }

            //PARA EL CALCULO DE ULTIMOS
            int [] ultimos;
            if (b.anulable == "A"){
                ultimos = new int[a.ultimos.length + b.ultimos.length];
                int j = 0;
                for (int i = 0; i < ultimos.length; i++){
                    if (i < a.ultimos.length){
                        ultimos[i] = a.ultimos[i];
                    } else {
                        ultimos[i] = b.ultimos[j];
                        j++;
                    }
                }
            } else {
                ultimos = b.ultimos;
            }
            
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if (a.anulable == "A" && b.anulable == "A"){
                anulable = "A";
            } else {
                anulable = "N";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,b,".",parser.contId,0, anulable, primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC2 = b.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC2.length; j++){
                    int nuevo = primerosC2[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
:}
        | TKBarra ARBOL:a ARBOL:b{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[a.primeros.length + b.primeros.length];
            int j = 0;
            for (int i = 0; i < primeros.length; i++){
                if (i < a.primeros.length){
                    primeros[i] = a.primeros[i];
                } else {
                    primeros[i] = b.primeros[j];
                    j++;
                }
            }
            //CALCULOS DE ULTIMOS
            int[] ultimos = new int[a.ultimos.length + b.ultimos.length];
            j = 0;
            for (int i = 0; i < ultimos.length; i++){
                if (i < a.ultimos.length){
                    ultimos[i] = a.ultimos[i];
                } else {
                    ultimos[i] = b.ultimos[j];
                    j++;
                }
            }
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if (a.anulable == "A" || b.anulable == "A"){
                anulable = "A";
            } else {
                anulable = "N";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,b,"\\|",parser.contId,0, anulable, primeros, ultimos);
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | TKAsterisco ARBOL:a{:
            //CALCULOS DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"*",parser.contId,0, "A", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC1 = a.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC1.length; j++){
                    int nuevo = primerosC1[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | TKMas ARBOL:a{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //PARA EL CALCULO DE ANULABLES
            String anulable;
            if(a.anulable == "N"){
                anulable = "N";
            } else {
                anulable = "A";
            }
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"+",parser.contId,0, anulable, primeros, ultimos);
            //CALCULO DE SIGUIENTES
            int[] ultimosC1 = a.ultimos;
            int[] primerosC1 = a.primeros;
            for (int i = 0; i < ultimosC1.length; i++){
                //SABEMOS QUE ES EN LISTASIGUIENTES EN I
                int temp = ultimosC1[i];
                for (int j = 0; j < primerosC1.length; j++){
                    int nuevo = primerosC1[j];
                    if (parser.ListaSiguientes.get(temp-1).siguientes.contains(nuevo) == false){
                        ListaSiguientes.get(temp-1).siguientes.add(nuevo);
                    }
                }
            }
            //ITERAMOS
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | TKInterrogacion ARBOL:a{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = a.primeros;
            //CALCULOS DE ULTIMOS
            int[] ultimos = a.ultimos;
            //CREAMOS EL NODO
            Nodo NuevoPadre = new Nodo(a,null,"?",parser.contId,0, "A", primeros, ultimos);
            parser.contId++;
            RESULT = NuevoPadre;
        :}
        | HOJAS:a{:
            RESULT = a;
        :};

HOJAS ::= TKParA:val0 identificador:val TKParC:val1{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,val0+val+val1,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, val);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //ITERAMOS
            parser.contId++;
            parser.num++;
            RESULT = NuevaHoja;
:}
        | caracterespecial:val{:
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,val,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, val);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //INGRESAMOS A LOS CONJUNTOS
            String cadena = val.replace("\\", "");
            List<String> lista = new ArrayList<String>();
            lista.add(cadena);
            Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(lista), val));
            //ITERAMOS
            parser.contId++;
            parser.num++;
            parser.contCon++;
            RESULT = NuevaHoja;
        :}
        | cadena:val{:
            String caracter = val.replace("\"", "");
            //PARA EL CALCULO DE PRIMEROS
            int[] primeros = new int[1];
            primeros[0] = parser.num;
            //PARA EL CALCULO DE PRIMEROS
            int[] ultimos = new int[1];
            ultimos[0] = parser.num;
            //CREAMOS EL NODO
            Nodo NuevaHoja = new Nodo(null,null,caracter,parser.contId,parser.num, "N", primeros, ultimos);
            //CALCULO DE SIGUIENTES
            TablaSiguientes elemento = new TablaSiguientes(parser.num, null, caracter);
            if (parser.ListaSiguientes == null){
                ListaSiguientes = new ArrayList<TablaSiguientes>();
                parser.ListaSiguientes.add(elemento);
            } else {
                parser.ListaSiguientes.add(elemento);
            }
            //INGRESAMOS A LOS CONJUNTOS
            List<String> lista = new ArrayList<String>();
            lista.add(caracter);
            Application.App.ListaConjuntos.add(new Conjunto(new ArrayList<>(lista), caracter));
            //ITERAMOS
            parser.contId++;
            parser.num++;
            parser.contCon++;
            RESULT = NuevaHoja;
        :};

DEFINICION ::= identificador:nombre TKDosPuntos cadena:lexema TKPuntoComa{:
    try{
        Application.App.ListaCadenas.add(new Cadena(lexema, nombre));
    }catch(Exception e){
        System.err.println("Error de cadenas: " + e);
    }
:}
            | DEFINICION identificador:nombre TKDosPuntos cadena:lexema TKPuntoComa{:
                try{
                    Application.App.ListaCadenas.add(new Cadena(lexema, nombre));
                }catch(Exception e){
                    System.err.println("Error de cadenas: " + e);
                }
            :};